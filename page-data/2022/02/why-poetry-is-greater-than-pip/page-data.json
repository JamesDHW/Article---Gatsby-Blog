{"componentChunkName":"component---src-templates-blog-post-blog-post-jsx","path":"/2022/02/why-poetry-is-greater-than-pip","result":{"data":{"markdownRemark":{"html":"<p><strong>Third-party software is essential to develop any modern software product. How we manage external packages can have a big impact on the robustness of our systems. In this article I will outline how packages are managed and contrast the Python and JavaScript package ecosystems.</strong></p>\n<p>The good thing about open source is that developers don't need to start from scratch with every new project. If I want to write a JS web app, I add the <a href=\"https://reactjs.org/\">React</a> library to my source code and import the functions that I need.</p>\n<p>If I want to run my code on another computer, I don't directly transfer the source code of the React library stored in my project along with my code - I just send you the bits of code I wrote, plus a note which tells your project, \"you'll need to download React if you want this code to work\".</p>\n<p>The thing is, React wasn't built \"from scratch\" either, it is also built on other third-party libraries. React keeps its own note of its dependencies and if my software uses React, it also needs to download all of its dependencies. These are called transitive dependencies.</p>\n<p>Importantly, when the React library is updated over time by Facebook and old versions become redundant. This means that I also need to keep track of the version(s) which are compatible with my code. My project might run fine using React v18, but break if you try to run it alongside v16.</p>\n<p>It's essential that I can track these dependencies accurately, so that whenever someone new wants to run my code, they can download the <em>exact</em> same libraries I have so that my software doesn't break for them.</p>\n<h1>A good example of dependency management: JavaScript</h1>\n<p>The node ecosystem has a good way of consistently ensuring that the correct versions of third-party modules are always used.</p>\n<p>All node packages are published on the node package registry <code class=\"language-text\">npmjs.com</code>. It is the job of the registry to securely store all the code for each version of each library and allow people to download specific versions of packages.</p>\n<p>Any node project that uses third-party packages from <code class=\"language-text\">npmjs</code> contains a <code class=\"language-text\">package.json</code> file which stores a list of the package versions it requires.</p>\n<p>Any computer looking to download node packages needs a package manager. There are two main ones for node: <code class=\"language-text\">npm</code> (node package manager - developed by <code class=\"language-text\">npmjs</code>) and <code class=\"language-text\">yarn</code> (developed bu Facebook). These are both command line interfaces (CLIs) which both go to <code class=\"language-text\">npmjs.com</code> and download packages into a local folder called <code class=\"language-text\">node_modules</code>. The <code class=\"language-text\">node_modules</code> are always downloaded to the folder of the project you're working in, so if you have two React projects, you will download React twice in each project folder.</p>\n<h2>An extra complexity</h2>\n<p>What if two of the packages you depend on both depend on a common package? For instance one depends on package <code class=\"language-text\">some_library v1.2</code> and the other depends on <code class=\"language-text\">some_library v1.0-1.9</code> (any version between <code class=\"language-text\">1.0</code> and <code class=\"language-text\">1.9</code> are acceptable to use).</p>\n<p>In this case, it makes sense to download the dependency only once and use a version that both libraries are happy to use.</p>\n<p>It is the job of the package manager to look at the entire dependency tree and answer the question, \"given these shared requirements, with these acceptable versions, which package versions does the project require\". The answer to this depends on the <em>combination</em> of all the project dependencies.</p>\n<p>Package managers use <strong>lockfiles</strong> (<code class=\"language-text\">package-lock.json</code> and <code class=\"language-text\">yarn.lock</code>) to save this dependency resolution. If a lockfile is present and sufficiently describes valid dependencies in the <code class=\"language-text\">package.json</code>, then the versions specified in the lockfile are installed. If there is no lockfile, or the versions in the lockfile no longer satisfy the <code class=\"language-text\">package.json</code>, then the dependencies are resolved again (to the latest valid versions) and saved to a new lockfile.</p>\n<p>Lockfiles mean that dependency resolutions are deterministic - every user will always get the same dependencies every time. This solves the \"it works on my machine\" conversation with bugs, as you can ensure you are running the same software on every machine.</p>\n<h1>Why PIP struggles</h1>\n<p>The registry for Python modules is called <code class=\"language-text\">PyPI</code> (Python Package Index at <code class=\"language-text\">pypi.org</code> - analogous to <code class=\"language-text\">npmjs.com</code> with node) and its default package manager is <code class=\"language-text\">PIP</code> (recursive acronym: Pip Installs Packages - analogous to <code class=\"language-text\">npm</code> with node). <code class=\"language-text\">PIP</code> was released in 2008 (initially as <code class=\"language-text\">pyinstall</code>), and can struggle to consistently manage packages for two main reasons.</p>\n<h2>1. Python dependencies are installed globally</h2>\n<p>Whereas node modules are installed in a <code class=\"language-text\">node_modules</code> folder for each project, Python installs package dependencies to a specific place on your computer (mine are saved at <code class=\"language-text\">/usr/local/lib/python3.9/site-packages</code>). This means that if you are developing more than one Python project on your computer at a time, which means you can't have two different versions of the same package on your computer at the same time (PIP overrides versions).</p>\n<p>This can cause some fiddling.</p>\n<h2>2. No lockfiles</h2>\n<p>PIP also doesn't have any way of deterministically resolving transient dependencies such as using a lockfile. This means that when someone installs your project for the first time, they will probably get some variation of the packages that you have - this means their code is different to yours and could work differently.</p>\n<h1>How does Poetry solve these issues</h1>\n<p>Poetry was developed to address some of these issues and improve package management and environment isolation in the Python world. Poetry uses a <code class=\"language-text\">pyproject.toml</code> file to keep track of dependencies, just like <code class=\"language-text\">package.json</code> for node.</p>\n<p>You can create a new project with Poetry with <code class=\"language-text\">poetry new</code> or add Poetry to an existing project using <code class=\"language-text\">poetry init</code>.</p>\n<h2>1. Isolate environments for each project</h2>\n<p>The global installation of packages is a restraint imposed by the language. In the Python world, this is solved by creating many virtual environments which each have their own version of Python installed. You can create a new virtualenv called <code class=\"language-text\">venv</code> in your project like so:</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">python3 -m venv .</code>\n        </deckgo-highlight-code>\n<p>This is essentially a folder in your project which acts as the \"root folder\" of a file system. Now Python packages sit in <code class=\"language-text\">./venv/lib/python3.9/site-packages</code>. When you want to activate this environment you run</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">source venv/bin/activate</code>\n        </deckgo-highlight-code>\n<p>Now your shell will look at your venv when you run <code class=\"language-text\">python</code> (this points at Python v3 rather than v2). You can close this venv by running <code class=\"language-text\">deactivate</code>.</p>\n<p>Poetry makes the creation and management of virtualenvs very easy.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">poetry shell # create and activate a new venv\npoetry env list # list all project venvs\npoetry env remove venv # delete the env called vnenv\nexit # deactivate the current venv</code>\n        </deckgo-highlight-code>\n<h2>2. Add lockfiles</h2>\n<p>After running <code class=\"language-text\">poetry shell</code>, you can instal dependencies to your environment:</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">poetry install # install dependencies in pyproject.toml\npoetry search dj # search PyPI for packages containing &#39;dj&#39;\npoetry add Django # add Django as a dependency to pyproject.toml</code>\n        </deckgo-highlight-code>\n<p>Just as with node package managers, Poetry uses lockfiles to resolve transient dependencies in a <code class=\"language-text\">poetry.lock</code> file. This allows us to recreate project dependencies exactly.</p>\n<p>Make sure to commit your lockfile to the source control of your project - when someone comes to run your project on a new machine, they get the same dependencies as you.</p>\n<h1>Conclusion</h1>\n<p>Poetry has some other nice features, but hopefully this article has outlined the main two advantages it has over using PIP in your project.</p>","frontmatter":{"date":"February 17, 2022","slug":"2022/02/why-poetry-is-greater-than-pip","title":"Why Poetry is greater than PIP","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABwlAAAcJQHgtf5oAAABgklEQVQY0yXQWyhDcRwH8O/OkcuoyYtSSklZKZEkL1Lysrx4GZJ4sklR7MVtZzV3KS9SLslcwkKmeJBSyhNmD+4ml2PjzLBDzOz/k7Pfy/fl26e+P/judoE7AiQCXCwFrpAWDl8mlsRkzIogIrCfoJLVdfWwdjZjzVqiNpnMmcsT5VgeL1PRmQaB8wYoN2kE+EWZj5r7gGpMnue3PwmbfsKC2K5eeULvSSCGhcMKKEzsciVNduhaFgZrhal9IkQRAa9H2Xi/MEXAJQuAgQAPawDokewYfSaseSXefq81ut7gD4ZTGWPClfiqMQ5tQ9di0xW37oRGbB1EXk0VeYCviyQ++CBEwMX/7BF5DDyC675dVQs3lFN/drWlPYxzzrxA/vhNZIzl9s/tRRc07iDPsNE1PG2m7+s0j3yenkq3wNdlkkp2myOgow8orDjm8iucyKo+qinVn/or9W6D2nzA/c9UfsiY0m20DKGqbT1ecma1h9wZRSQlgryxHD0ngJ66FfAPqfPB5bMTGlEAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/Article--Gatsby-Blog/static/87aa48ebc15cae6bcbee9b90c8f1b70f/7f519/thumbnail.png","srcSet":"/Article--Gatsby-Blog/static/87aa48ebc15cae6bcbee9b90c8f1b70f/43537/thumbnail.png 177w,\n/Article--Gatsby-Blog/static/87aa48ebc15cae6bcbee9b90c8f1b70f/a6bb3/thumbnail.png 354w,\n/Article--Gatsby-Blog/static/87aa48ebc15cae6bcbee9b90c8f1b70f/7f519/thumbnail.png 708w","sizes":"(min-width: 708px) 708px, 100vw"},"sources":[{"srcSet":"/Article--Gatsby-Blog/static/87aa48ebc15cae6bcbee9b90c8f1b70f/c3bf1/thumbnail.avif 177w,\n/Article--Gatsby-Blog/static/87aa48ebc15cae6bcbee9b90c8f1b70f/251ac/thumbnail.avif 354w,\n/Article--Gatsby-Blog/static/87aa48ebc15cae6bcbee9b90c8f1b70f/dcc68/thumbnail.avif 708w","type":"image/avif","sizes":"(min-width: 708px) 708px, 100vw"},{"srcSet":"/Article--Gatsby-Blog/static/87aa48ebc15cae6bcbee9b90c8f1b70f/a3230/thumbnail.webp 177w,\n/Article--Gatsby-Blog/static/87aa48ebc15cae6bcbee9b90c8f1b70f/a04ec/thumbnail.webp 354w,\n/Article--Gatsby-Blog/static/87aa48ebc15cae6bcbee9b90c8f1b70f/ab4c5/thumbnail.webp 708w","type":"image/webp","sizes":"(min-width: 708px) 708px, 100vw"}]},"width":800,"height":200}}}}}},"pageContext":{"slug":"2022/02/why-poetry-is-greater-than-pip"}},"staticQueryHashes":[]}