{"componentChunkName":"component---src-templates-blog-post-blog-post-jsx","path":"/2022/02/book-summary-clean-code","result":{"data":{"markdownRemark":{"html":"<p><strong>Want to know how to write Clean Code? Robert C. Martin brings us a pragmatic guide to improving the quality of our programs. In this article I hope to summarise many of the practices that he promotes in his book so you can quickly apply them to your own code.</strong></p>\n<h1>Forewarning</h1>\n<p>It's worth mentioning (as is done in the book) that memorising these principles is not simply enough - you will need to spend hours applying the techniques in Clean Code to become a better programmer. I would recommend using this article as an overview of the topics covered and dive into the book itself to see the details where you feel you will benefit the most.</p>\n<h1>1. The cost of bad code and the essence clean code</h1>\n<p>Martin starts the book by warning of the cost of owning a mess. In short, systems that are a mess are expensive and painful to maintain.</p>\n<p>It's not uncommon for the code becomes so unmaintainable that the developers rebel and call for an overhaul of an existing system. Managers relent and a new team is formed, racing to rebuild the legacy system.</p>\n<p>Productivity briefly spikes for the new team, but as the new code base grows, productivity slows and it takes years for the new system to catch up to the old; by this time the original team have gone and everyone is already calling for an overhaul of the new system.</p>\n<p>Martin goes on to ask many well-known programmers to define what \"clean\" code is. They converge on similar themes; the essence of clean code is that <strong>it is simple and conveys clearly its intent to the reader</strong>. Many of the practices promoted by Martin are simply ways of making the intent of your code clearer.</p>\n<p>Martin advocates for the Boy Scout's Rule:</p>\n<p><strong>Leave the campground (code base) cleaner than how you found it.</strong></p>\n<h1>2. Meaningful names</h1>\n<p>Naming variables, functions, and classes sensibly goes a very long way to making your code more understandable by a reader. Obscure, uninformative, or misinformative names require the reader to derive what is going on in your code, potentially turning a five-minute job into a thirty-minute job. Choosing a good name can take a long time, but this is time being invested in a cleaner code base.</p>\n<p>Choose names that:</p>\n<ul>\n<li>\n<p><strong>Reveal the intent</strong> of the variable/ function/ class (can I guess what everything does without needing read the logic)</p>\n</li>\n<li>\n<p><strong>Avoid disinformation</strong> (don't call something <code class=\"language-text\">accountList</code> unless it really is a list!)</p>\n</li>\n<li>\n<p><strong>Avoid non-information</strong> (don't call a variable <code class=\"language-text\">i</code> unless indexing in a loop)</p>\n</li>\n<li>\n<p><strong>Make meaningful distinctions</strong> - every named \"thing\" should be something distinct, and the difference between these distinct things should be clear. For example, having <code class=\"language-text\">car</code> and <code class=\"language-text\">carInfo</code> is not a helpful distinction (do you really need two variables here if you can't name them against distinct concepts?).</p>\n</li>\n<li>\n<p><strong>Are pronounceable</strong> - make life easy for yourself!</p>\n</li>\n<li>\n<p><strong>Are searchable</strong> - make it easy to grep search for the variable you're looking for (unique names trump common ones).</p>\n</li>\n<li>\n<p><strong>Are not encoded</strong> - don't use prefixes; if your variables are suitably named these shouldn't be required and will at best be ignored by readers.</p>\n</li>\n<li>\n<p><strong>Avoid mental mapping</strong> - do not require the reader to translates your name to something else for them to make sense of it.</p>\n</li>\n<li>\n<p><strong>Follow a convention</strong> - use one name for one concept and stick to it.</p>\n</li>\n<li>\n<p><strong>Refer to the solution domain</strong> - it will be programmers reading your code, so don't be afraid to use CS terms.</p>\n</li>\n<li>\n<p><strong>Refer to the problem domain</strong> - a programmer can always ask a domain expert what the name means where solution domain names don't make sense to use.</p>\n</li>\n<li>\n<p><strong>Add meaningful context</strong> - add the context that will be required by the reader at the level of abstraction that the reader will be using the variable (the variable <code class=\"language-text\">state</code> makes sense next to its sibling variable <code class=\"language-text\">addressLineOne</code>, <code class=\"language-text\">addressLineTwo</code> but is extremely misleading used out of this context).</p>\n</li>\n<li>\n<p><strong>Don't add gratuitous context</strong> - if you prefix all variables in the <code class=\"language-text\">Customer</code> class with <code class=\"language-text\">customer</code> then every time you type <code class=\"language-text\">c</code> into your IDE, it will take nine keystrokes before your autocomplete starts helping you out - don't make your IDE work against you!</p>\n</li>\n<li>\n<p><strong>Use verbs for functions</strong> - verb/ noun pairs are very descriptive (<code class=\"language-text\">write(name)</code> shows that <code class=\"language-text\">name</code> is being written - even better would be <code class=\"language-text\">writeField(name)</code> as we have also described what <code class=\"language-text\">name</code> is in the function). Also, try to use the same verbs everywhere (don't mix <code class=\"language-text\">fetch</code> and <code class=\"language-text\">get</code>)</p>\n</li>\n</ul>\n<p>Don't underestimate the power that the choice of your names can have on cleanliness of your code!</p>\n<h1>3. Functions</h1>\n<h2>Small!</h2>\n<p>Functions should hardly ever be longer than 20 lines - any longer and you need to break your logic down into smaller steps. This reduces the mental strain on the reader and makes it easier to spot any bugs in your own code. Breaking down your code into smaller functions means that you naturally begin to label (by creating a new function with a variable name) and sort the logic of your code into related steps.</p>\n<p>Naturally, small functions also avoid excessive indentation, which increases readability.</p>\n<h2>Do one thing!</h2>\n<p><em>Functions should do one thing. They should do it well. They should do it only.</em></p>\n<p>If you can extract another function from within your function, with a name which is not merely a restatement of the outer function's name, then you should do so. For example:</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">login(username, password) {\n    if verifyUserCredentials(username, password){\n        return this.Session.initialise(username);\n    }\n    throw Exception(&#39;Invalid user credentials&#39;);\n}\n\nverifyUserCredentials (username, password) {\n    const user = this.getUserByUsername(username);\n    if (password === dcrypt(user.passwordHash)) {\n        return true;\n    }\n    return false;\n}</code>\n        </deckgo-highlight-code>\n<p>trumps</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">login(username, password) {\n    const user = this.getUserByUsername(username);\n    if (password === dcrypt(user.passwordHash)) {\n        return this.Session.initialise(username)\n    }\n    throw Exception(&#39;Invalid user credentials&#39;);\n}</code>\n        </deckgo-highlight-code>\n<p>There may be many steps, but the first example splits the function into a non-trivial extra step of verifying the credentials. If we need to verify credentials elsewhere this will reduce duplication.</p>\n<p>If you can extract more functions from the function you are writing, then your function is doing more than one thing.</p>\n<p>On the topic of <code class=\"language-text\">switch</code> statements (which by their nature, perform N functions), Martin says they can be tolerated if buried in the basement of an abstract factory and are used to implement polymorphism.</p>\n<p>The obvious problem arises: what is \"one\" thing? It's difficult to give a one-size-fits-all rule, but considering levels of abstraction can help us determine this...</p>\n<h2>One level of abstraction</h2>\n<p>An interesting and important concept that Martin vocalised for me was ensuring that we only have one level of abstraction per function. Examples of different levels of abstraction would be:</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">getHtml() // high-level \nconst pageTitle = getPageSectionTitle() // mid-level\nshoppingList.append(shoppingItem) // low-level</code>\n        </deckgo-highlight-code>\n<p>Keeping these levels of concepts separated cleans up your code and only shows the reader the level of detail they would expect to see in that function.</p>\n<p>Martin describes the <em>step-down rule</em> to check if your abstractions are of the right level; you should be able to read a program as if it were a series of <em>TO</em> paragraphs. Here is an example in JavaScript:</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">function registerUser () {\n    const contactDetails = collectUserContactDetails();\n    const paymentDetails = collectUserPaymentDetails();\n    const user = {...contactDetails, ...paymentDetails};\n    createNewUser(user);\n}</code>\n        </deckgo-highlight-code>\n<p><em>To register a user, we collect the user's contact details, then we collect the user's payment details, then we combine the two and create a new user from the result.</em></p>\n<p>This reads like a simple set of instructions which is understandable to a non-technical reader. We can then move down one level of abstraction and do something similar for <code class=\"language-text\">collectUserContactDetails</code> to describe how this action is performed.</p>\n<p>This way of organising concepts can be very difficult and requires practice. It comes hand-in-hand with making sure that your functions do only one thing.</p>\n<h2>Fewer arguments</h2>\n<p>The ideal number of arguments to pass to a function is zero, but you should never need to use more than three. Passing round arguments uses conceptual power and can expose a lot of the inner workings of a function.</p>\n<p>In the case that we are tempted to use more than 3 arguments, notice that some of these variables can be grouped into an object or list of related values which express meaning as a single concept.</p>\n<p>Never use boolean flag arguments which change the behaviour of your function - it is a sign that your function has too much responsibility!</p>\n<h2>Side effects</h2>\n<p>A function that contains side effects is one that creates a change outside of its own scope. Depending on when you call it, the state in your upper scope can be affected, which is confusing and creates a temporal coupling in your code.</p>\n<p>Side effects are a way of lying to the reader about what your function is doing. Consider:</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">function checkPassword (userId, passwordToCheck) {\n    const user = getUserById(userId);\n    if (user) {\n        const encodedPassword = user.passwordHash;\n        const userPassword = dcrypt(encodedPassword);\n        if (userPassword === passwordToCheck) {\n            initializeSession();\n            return true;\n        };\n    }\n    return false\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">checkPassword</code> will return the correct output, however it also calls <code class=\"language-text\">initializeSession</code> if our password is correct (which changes some state outside the scope of the function). This code is just asking for bugs to arise.</p>\n<p>Another way to give another developer a nasty surprise is to mutate a data structure passed into your function. They will have hours of fun trying to figure out why their code is doing something strange. <strong>You should always avoid mutating data</strong> - create a new object and return it!</p>\n<p>Here is an example of how this can go wrong:</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">\n    // (in the body of some outer function)\n    ...\n    console.log({allIds}) // -&gt; { allIds: [1, 2, 3] }\n\n    if (!isIdRegistered(id, allIds)) {\n        allIds.append(id)\n    }\n\n    console.log({allIds}) // -&gt; { allIds: [4] }\n    ...\n\nfunction isIdRegistered(id, allIds) {\n    for (let i=0; i&lt;allIds.length; i++) {\n        const registeredId = allIds.pop();\n        if (id === registeredId) return true;\n    }\n    return false;\n}\n</code>\n        </deckgo-highlight-code>\n<p>Our function, <code class=\"language-text\">isIdRegistered</code>, mutates the <code class=\"language-text\">allIds</code> list with the <code class=\"language-text\">.pop</code> method. The outer body logic reads as: check if the <code class=\"language-text\">id</code> is already registered, and if not, add it to the list of <code class=\"language-text\">allIds</code>. A reader would not expect <code class=\"language-text\">allIds</code> to be affected in the way it is by this function.</p>\n<p>Pure functions (without side effects) should be the only ones you use.</p>\n<h2>Command-query separation</h2>\n<p>Functions should either do something (perform some action on data) or answer something (retrieve data), not both; if it does, your function is doing more than one thing.</p>\n<h2>Extract try/catch blocks</h2>\n<p>Error handling is one thing - a function that handles errors should do nothing else. Try/except block are confusing and should be extracted to their own functions so that the intent of the function is clearer to the reader. For example:</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">function delete(page) {\n    try {\n        deletePageAndReferences(page);\n    }\n    catch (Exception e) {\n        logError(e);\n    }\n}\n\nfunction deletePageAndReferences(page) {\n    deletePage(page);\n    registry.deleteReference(page.name);\n    configKeys.deleteKey(page.name.makeKey());\n}</code>\n        </deckgo-highlight-code>\n<p>trumps:</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">function delete(page) {\n    try {\n        deletePage(page);\n        registry.deleteReference(page.name);\n        configKeys.deleteKey(page.name.makeKey());\n    }\n    catch (Exception e) {\n        console.error(e.message);\n        throw e;\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>This demonstrates that error handling should be classified as one thing. Extracting the exception handling makes it easy to understand and ignore. This removes the unnecessary complexity for the reader.</p>\n<h2>DRY (Don't repeat yourself)</h2>\n<p>It goes without saying that extracting reusable functions means that you shouldn't be repeating any of your code, extracting out functions into building blocks and calling those functions. This means you only need to change your code in one place rather than many when business logic changes.</p>\n<h1>4. Comments</h1>\n<p>In general, don't use comments. If you need to add extra explanation to your code, it's a sign that you're not writing maintainable code. Even with the best of intentions, when the code changes (and it will), comments are often not updated by the person who changes the code, cluttering your code base with redundant comments that the dev team are too nervous to remove.</p>\n<p>It is easier to list the times a comment is justified:</p>\n<ol>\n<li>Legal comments (e.g. copyright).</li>\n<li>Revealing intent behind a decision which would otherwise be obscure.</li>\n<li>Clarifying obscure methods of a standard (external) library that you can't refactor.</li>\n<li>Warnings to other programmers of the consequences of running some code.</li>\n<li>TODO comments - these should be immediately documented with a plan to address the tech-debt.</li>\n</ol>\n<p>If you do leave a comment, make sure it is concise and serves a specific purpose.</p>\n<p>Please, please, please, don't commit commented out code!</p>\n<h1>5. Formatting</h1>\n<p>Formatting is important - it helps to make your code more readable.</p>\n<p>Like smaller functions, smaller files are easier to understand - aim for fewer than 150 lines if possible.</p>\n<p>Aim to have the highest level of abstraction closer to the top to give the reader the broadest overview first. As you move down the page, the functions give more detail as the user requires - think of the order like a newspaper (the headline and summary come at the top with the details coming lower down the page).</p>\n<p>Have a shared set of linting rules which let your IDE auto-format your code on save and keep a common structure between the whole development team.</p>\n<h1>6. Objects and data structures</h1>\n<p>Martin describes data/object anti-symmetry: data structures should have no functions and expose their data, whereas objects should expose functions which operate on their data. These object methods hide the implementation details by creating an abstraction that programmers can interface with.</p>\n<p>If you have simple data structures with functions that act on them and you need to change the structure of the data, all of your functions will need to change their implementation. On the other hand it would be very easy to add a new function which acts on the data.</p>\n<p>If you use objects which each expose methods to access data, it is very easy to add a new data type (just add a new class which implements the methods), however it is difficult to change the behaviour of a method, because we need to change the implementation in many places (we need to change the behaviour wherever each class implements its method).</p>\n<p>Consider whether it is likely you will be changing the behaviour or structure of the data.</p>\n<p>Martin warns against creating hybrids, where classes have methods that act on the data, but also have public variables (or public accessors and mutators) which directly expose the innards, creating the worst of both worlds.</p>\n<h2>The law of Demeter</h2>\n<p><em>A module should not know about the innards of the objects it manipulates.</em></p>\n<p>This means that your code should <strong>not</strong> call methods on returned objects like so:</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();</code>\n        </deckgo-highlight-code>\n<p>This creates a strong coupling between implementations across multiple modules and is known as <em>train-wreck code</em> due to the coupling (like train cars).</p>\n<p>If <code class=\"language-text\">ctxt</code> was simply a data structure, then the law of Demeter would not apply (as data structures naturally expose their innards).</p>\n<p>We should be telling <code class=\"language-text\">ctxt</code> to <em>do</em> something (it's not a data structure), not return something for another method to use. If we look at the outer context of how this <code class=\"language-text\">outputDir</code> is being used, we see that it is outputting some data to a file. We can tell <code class=\"language-text\">ctxt</code> to do this for us:</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">String outFile = outputDir + &quot;/&quot; + className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;; // notice mixed levels of abstraction!\nFileOutputStream fout = new FileOutputStream(outFile);\nBufferedOutputStream bos = new BufferedOutputStream(fout);</code>\n        </deckgo-highlight-code>\n<p>becomes</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName);</code>\n        </deckgo-highlight-code>\n<h2>Data transfer objects (DTO)</h2>\n<p>A DTO is an class with public variables and no methods. They are often useful where we interface with databases. <em>Active records</em> are a type of DTO which contain navigational methods such as <code class=\"language-text\">find</code> or <code class=\"language-text\">navigate</code>. Martin warns us not to be tempted to add business logic here; active records should be treated like data structures (which simply expose their data).</p>\n<h1>7. Error Handling (by Michael Feathers)</h1>\n<p>This section by Michael Feathers describes how we can handle errors and separate business logic from our error handling.</p>\n<h2>Prefer exceptions to returning error codes</h2>\n<p>Exceptions are designed to be thrown when something goes wrong. It is a way of your program giving you feedback to you about what went wrong - handling exceptions explicitly leads to more robust code. Additionally, you should stick to one convention on error handling throughout your project (otherwise you will be left with a mess).</p>\n<p>If you return error codes, the caller must deal with the exception immediately:</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">if (deletePage(page) !== CODES.OK){\n    console.error(&#39;delete failed&#39;);\n    return CODES.ERROR;\n}\nif (registry.deleteReference(page.name) !== CODES.OK){\n    console.error(&#39;deleteReference from registry failed&#39;);\n    return CODES.ERROR;\n}\nif (configKeys.deleteKey(page.name.makeKey()) !== CODES.OK){\n    console.error(&#39;configKey not deleted&#39;);\n    return CODES.ERROR;\n}\n\nconsole.log(&#39;page deleted&#39;);\nreturn CODES.OK;</code>\n        </deckgo-highlight-code>\n<p>as opposed to throwing using exceptions where the happy path code can be separated from error processing:</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">try {\n    deletePage(page);\n    registry.deleteReference(page.name);\n    configKeys.deleteKey(page.name.makeKey());\n}\ncatch (Exception e) {\n    console.error(e.message);\n    throw e;\n}</code>\n        </deckgo-highlight-code>\n<h2>Use unchecked exceptions</h2>\n<p>Languages like Java give programmers the ability to specify the exceptions a method can throw - the code will fail to compile if there are inconsistencies in exceptions. Feathers argues that the advantages are not worth the price of checked exceptions.</p>\n<p>The price of checked exceptions is a violation of the Open/Closed Principle. If I declare a new type of exception three layers of abstraction down, I must propagate that declaration up to the top level of abstraction.</p>\n<p>Many languages without checked exceptions have produced maintainable code - Feathers argues that this suggests they are not necessary.</p>\n<h2>Provide context with exceptions</h2>\n<p>Your error messages should provide enough context for you to quickly identify the source of the error (the operation and type of failure).</p>\n<h2>Define exception classes in terms of the caller's needs</h2>\n<p>When we define exception classes in an application, our most important concern should be how they are caught.</p>\n<p>Feathers gives us an example of where exceptions are handled poorly:</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">ACMEPort port = new ACMEPort(12);\n\ntry {\n    port.open();\n} catch (DeviceResponseException e) {\n    reportPortError(e);\n    logger.log(&quot;Device response exception&quot;, e);\n} catch (ATM1212UnlockedException e) {\n    reportPortError(e);\n    logger.log(&quot;Unlock exception&quot;, e);\n} catch (GMXError e) {\n    reportPortError(e);\n    logger.log(&quot;Device response exception&quot;);\n} finally {\n    ...\n}</code>\n        </deckgo-highlight-code>\n<p>In the context of calling <code class=\"language-text\">port.open()</code>, we only really care that there was a failure to open the port (not the specifics), which leads to duplication.</p>\n<p>The proposed solution is to wrapping the third-party (<code class=\"language-text\">ACMEPort</code>) API in our own class:</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">public class LocalPort {\n    private ACMEPort innerPort;\n\n    public LocalPort(int portNumber) {\n        innerPort = new ACMEPort(portNumber);\n    }\n\n    public void open() {\n        try {\n            innerPort.open();\n        } catch (DeviceResponseException e) {\n            throw new PortDeviceFailure(e);\n        } catch (ATM1212UnlockedException e) {\n            throw new PortDeviceFailure(e);\n        } catch (GMXError e) {\n            throw new PortDeviceFailure(e);\n        }\n    }\n}\n\n...\n\nLocalPort port = new LocalPort(12);\n\ntry {\n    port.open();\n} catch (PortDeviceFailure e) {\n    reportError(e);\n    logger.log(e.getMessage(), e);\n} finally {\n    ...\n}</code>\n        </deckgo-highlight-code>\n<p>Wrapping third-party APIs is a best practice which allows you to work with an API you have defined and are comfortable with. Creating an abstraction also minimises the cost of swapping out the third-party library later.</p>\n<h2>Know when <em>not</em> to use try/catch</h2>\n<p>Consider the following code:</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">try {\n    MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());\n    m_total += expenses.getTotal();\n} catch(MealExpensesNotFound e) {\n    m_t += getMealPerDiem();\n}</code>\n        </deckgo-highlight-code>\n<p>We are using a <code class=\"language-text\">try</code>/<code class=\"language-text\">catch</code> as part of the normal flow of a calculation. In this case, we can clean up our code by making <code class=\"language-text\">expenseReportDAO</code> return a <code class=\"language-text\">MealExpenses</code> object even in the special case where no meals are found:</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"material\" line-numbers=\"true\"  >\n          <code slot=\"code\">MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());\nm_total += expenses.getTotal();\n\n...\n\npublic class PerDiemMealExpenses implements MealExpenses {\n    public int getTotal() {\n        // return the per diem default\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>Now the client doesn't need to deal with the exceptional behaviour as it is encapsulated in the special case object (this is called the <em>special case pattern</em>).</p>\n<h2>Avoiding null</h2>\n<p>It is a red flag if your code has/ requires <code class=\"language-text\">null</code> checks everywhere. Feathers gives us two rules for this:</p>\n<ol>\n<li>Don't return <code class=\"language-text\">null</code> from any of your functions.</li>\n<li>Don't pass <code class=\"language-text\">null</code> to any of your functions.</li>\n</ol>\n<p>Consider throwing exceptions or returning a special case instead of returning <code class=\"language-text\">null</code>.</p>\n<h1>8. Boundaries (by James Grenning)</h1>\n<h2>Using third-party code</h2>\n<p>There is a tension between interfaces of third-part code - providers strive for broad applicability, whereas users want interfaces specific to their use case.</p>\n<p>Grenning gives the example of <code class=\"language-text\">java.util.Map</code> as a third-party interface. This module exposes many methods (such as <code class=\"language-text\">clear</code>) that we might not want to directly expose. He suggests that we wrap the third-party code which will restrict the interface to our specific use case. It also means that we only need to make changes in one place if we the third-party interface changes.</p>\n<p>Not every case of <code class=\"language-text\">Map</code> requires wrapping, but Grenning advises against passing <code class=\"language-text\">Map</code>s (or other interfaces at a boundary) around your system - keep these interfaces encapsulated.</p>\n<p>Grenning proposes that when integrating third-party code, we should use <em>learning tests</em> to assert that the parts of the third party code behave as expected so that when we come to debug our own code, we are certain that this is not a third-party error.</p>\n<p>These learning tests help us to learn about the integration and also support us when we come to migrate to newer versions to ensure that our code remains compatible with the library.</p>\n<h2>Code that is yet to exist</h2>\n<p>Grenning describes a technique he used for where the API he wished to use had not yet been written. His team wrote an <strong>adapter</strong>, which encapsulated the interaction with the un-finished API, and whenever they ran into some functionality of the interface that they expected to exist, they wrote a method in the adapter for it. This meant that when the third-party API was finished, their system was ready, excpet from creating the interface to the third-party.</p>\n<h2>Clean Boundaries</h2>\n<p>Grenning finishes this section by outlining that the boundaries between different systems are the points which often experience changes. We should isolate the interfaces between external systems so as to contain these maintenance points. We can wrap external code, or use an adapter to create a single point of interface. It is better for our code to speak to systems that we control.</p>\n<h1>9. Unit testing</h1>\n<p>It's not a surprise that Martin has positive things to say about test-driven development.</p>\n<h2>The three laws of TDD</h2>\n<ol>\n<li>First Law You may not write production code until you have written a failing unit test.</li>\n<li>Second Law You may not write more of a unit test than is sufficient to fail, and not compiling is failing.</li>\n<li>Third Law You may not write more production code than is sufficient to pass the currently failing test.</li>\n</ol>\n<p>Following these rules means we are locked into a cycle, where failing test code is written just before any addition to the production code is made.</p>\n<p>How do we manage to keep this section of our code base clean?</p>\n<h2>Keeping clean tests</h2>\n<p>Dirty tests are worse than no tests at all. They require maintaining, and the cost of maintaining dirty tests becomes very high as the code base evolves. However if you discard your automated tests, how can we be sure that any changes work as expected? Without automated tests, your production code will begin to rot.</p>\n<p>Automated tests are the safety net that empowers you to make improvements to your code whilst reducing the fear that these changes are bugs.</p>\n<p><em>Test code is just as important as production code.</em></p>\n<h2>Clean tests</h2>\n<p>Once again, readability is key to keeping good tests - the intent of the code should be clear! Aim for clarity, simplicity, and density of expression.</p>\n<p>Tests should clearly follow the <strong>build-operate-check</strong> pattern; the first part builds test data, the second part operates on it, and the third asserts that we have our expected output.</p>\n<p>As in production code, we must refactor our tests into succinct and expressive forms.</p>\n<p>Martin argues that we should form our own domain-specific testing language (specialised functions and utilities) which evolves as we develop our code base.</p>\n<h2>One assert per test</h2>\n<p>Having a single assertion per test allows the reader to quickly understand the single intent of the test. If there are multiple assertions, it suggests that a test is doing more than one thing and can be split into two tests (think of the parallel to functions only doing one thing).</p>\n<p>Martin proposes that these tests form a <strong>given-when-then</strong> convention, which he uses to name utilities in his testing language. This follows the build-operate-check pattern and helps simplify our tests (anything other than a given-when-then can be extracted).</p>\n<p>When we need to separate out tests to have a single assert, we can put the given-when code in a <code class=\"language-text\">Before</code> method and only have the assertion in each test.</p>\n<h2>Single concept per test</h2>\n<p>Don't force the reader to derive what each part of each test is doing - split your tests out if they cover different concepts.</p>\n<p>You can write <em>Given ...</em> statements to figure out if tests cover the same concept. If the same test covers multiple premises, then they should be split out.</p>\n<h2>FIRST</h2>\n<p>Tests should be:</p>\n<ol>\n<li>Fast - when they are slow you will be tempted to run them infrequently.</li>\n<li>Independent - they should be able to run independently and in any order to prevent cascading issues.</li>\n<li>Repeatable - in any environment (in CI or on your laptop). They should be deterministic, or you will rationalise why they are failing.</li>\n<li>Self-validating - they should have boolean output and check their success automatically.</li>\n<li>Timely - tests should be written in a timely manner (before you write your production code).</li>\n</ol>\n<!-- # 10. Classes (with Jeff Langr) -->\n<h1>Conclusion</h1>\n<p>Ironically, the use of the word \"code\" to describe a program may itself be unhelpful.</p>\n<p>The essence of <em>Clean Code</em> is in the clear intent to the reader - that is to say that <em>your programs shouldn't be encoded</em> to the human reader!</p>","frontmatter":{"date":"February 01, 2022","slug":"2022/02/book-summary-clean-code","title":"Book summary: Clean Code","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABwlAAAcJQHgtf5oAAABoElEQVQY0wGVAWr+AMLCwwDd3d0AxcXFDtvb3E7U1NU4////ANfX2ADq6uoA////APr5+QAAAAAA2tnaS8PDxBTd3d4AOjo/A83Nzi7q6uoA5eTkAPj49wD09PQAANTU1QLf3+AA3t7fedHR0lLg4OCM0tLTf8/O0GPW1dZz29rbgN3c3Vba2ttUzs7OcM3Nzlbc3N1z1NPUfd7e36nY2Nh+0tLTKujp6ADPz9ABAAAAAADR0NIA4+PjY+Pj42jd3N2H4ODgvdnY2avh4eLI39/gn9zb3Hfl5OVC1tbXftfX2JDi4uKu3t7fp+Tj5KLi4eLM1dXWNsbGxwD///8AAKmpqwuVk5gOhoSKD7OztTuYl5sZmpqdGKChpB+lpqkhjo2RHJKTlxR/f4UQu7u+LK+usiOioqUVqaisH6SjpiKenqIXjo2QEIuLjhCNjY8FAJOTlz6Vk5dRk5KWYZCQlWORkZZZkZKXU4yOkkeNj5RpjY+TcIeKj0eRkpdrio2RWIqLj1OLi5A/j46TZI6NkmCJiYtSiYiLX42NkHWNjY80q2L0IPgRNDwAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/blog/static/f23f317e83b44b3e4c59425ebffaf6bb/7f519/thumbnail.png","srcSet":"/blog/static/f23f317e83b44b3e4c59425ebffaf6bb/43537/thumbnail.png 177w,\n/blog/static/f23f317e83b44b3e4c59425ebffaf6bb/a6bb3/thumbnail.png 354w,\n/blog/static/f23f317e83b44b3e4c59425ebffaf6bb/7f519/thumbnail.png 708w","sizes":"(min-width: 708px) 708px, 100vw"},"sources":[{"srcSet":"/blog/static/f23f317e83b44b3e4c59425ebffaf6bb/c3bf1/thumbnail.avif 177w,\n/blog/static/f23f317e83b44b3e4c59425ebffaf6bb/251ac/thumbnail.avif 354w,\n/blog/static/f23f317e83b44b3e4c59425ebffaf6bb/dcc68/thumbnail.avif 708w","type":"image/avif","sizes":"(min-width: 708px) 708px, 100vw"},{"srcSet":"/blog/static/f23f317e83b44b3e4c59425ebffaf6bb/a3230/thumbnail.webp 177w,\n/blog/static/f23f317e83b44b3e4c59425ebffaf6bb/a04ec/thumbnail.webp 354w,\n/blog/static/f23f317e83b44b3e4c59425ebffaf6bb/ab4c5/thumbnail.webp 708w","type":"image/webp","sizes":"(min-width: 708px) 708px, 100vw"}]},"width":800,"height":200}}}}}},"pageContext":{"slug":"2022/02/book-summary-clean-code"}},"staticQueryHashes":[]}